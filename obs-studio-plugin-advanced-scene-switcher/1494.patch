From ff552da0fcf8b74c177aebd9e667bc3af8144947 Mon Sep 17 00:00:00 2001
From: WarmUpTill <19472752+WarmUpTill@users.noreply.github.com>
Date: Thu, 20 Nov 2025 19:38:19 +0100
Subject: [PATCH 1/3] Add retry mechanism for downloading dependencies

---
 cmake/common/buildspec_common.cmake | 48 +++++++++++++++++++++--------
 1 file changed, 35 insertions(+), 13 deletions(-)

diff --git a/cmake/common/buildspec_common.cmake b/cmake/common/buildspec_common.cmake
index 369920349..b3fd96fbb 100644
--- a/cmake/common/buildspec_common.cmake
+++ b/cmake/common/buildspec_common.cmake
@@ -180,24 +180,46 @@ function(_check_dependencies)
       set(url ${url}/${version}/${file})
     endif()
 
+    set(MAX_DOWNLOAD_RETRIES 3)
+    set(RETRY_DELAY 60) # seconds
+
     if(NOT EXISTS "${dependencies_dir}/${file}")
       message(STATUS "Downloading ${url}")
-      file(
-        DOWNLOAD "${url}" "${dependencies_dir}/${file}"
-        STATUS download_status
-        EXPECTED_HASH SHA256=${hash})
-
-      list(GET download_status 0 error_code)
-      list(GET download_status 1 error_message)
-      if(error_code GREATER 0)
-        message(STATUS "Downloading ${url} - Failure")
+
+      set(download_success FALSE)
+
+      foreach(i RANGE 1 ${MAX_DOWNLOAD_RETRIES})
+        message(STATUS "Attempt ${i}/${MAX_DOWNLOAD_RETRIES} for ${url}")
+
+        file(
+          DOWNLOAD "${url}" "${dependencies_dir}/${file}"
+          STATUS download_status
+          EXPECTED_HASH SHA256=${hash})
+
+        list(GET download_status 0 error_code)
+        list(GET download_status 1 error_message)
+
+        if(error_code EQUAL 0)
+          message(STATUS "Downloading ${url} - success on attempt ${i}")
+          set(download_success TRUE)
+          break()
+        else()
+          message(WARNING "Download failed (attempt ${i}): ${error_message}")
+          file(REMOVE "${dependencies_dir}/${file}")
+
+          if(NOT i EQUAL MAX_DOWNLOAD_RETRIES)
+            message(STATUS "Retrying in ${RETRY_DELAY} seconds...")
+            execute_process(COMMAND ${CMAKE_COMMAND} -E sleep ${RETRY_DELAY})
+          endif()
+        endif()
+      endforeach()
+
+      if(NOT download_success)
         message(
           FATAL_ERROR
-            "Unable to download ${url}, failed with error: ${error_message}")
-        file(REMOVE "${dependencies_dir}/${file}")
-      else()
-        message(STATUS "Downloading ${url} - done")
+            "Unable to download ${url} after ${MAX_DOWNLOAD_RETRIES} attempts")
       endif()
+      message(STATUS "Downloading ${url} - done")
     endif()
 
     if(NOT EXISTS "${dependencies_dir}/${destination}")

From 6a61839c6547d8ed89efcea14df96c642f17c256 Mon Sep 17 00:00:00 2001
From: WarmUpTill <19472752+WarmUpTill@users.noreply.github.com>
Date: Sat, 22 Nov 2025 07:23:17 +0100
Subject: [PATCH 2/3] Fix crash on macro tab setup

---
 lib/macro/macro-tab.cpp | 11 +++++++----
 1 file changed, 7 insertions(+), 4 deletions(-)

diff --git a/lib/macro/macro-tab.cpp b/lib/macro/macro-tab.cpp
index 452119d08..2cc3e5a7d 100644
--- a/lib/macro/macro-tab.cpp
+++ b/lib/macro/macro-tab.cpp
@@ -615,17 +615,20 @@ setupToolBar(const std::initializer_list<std::initializer_list<QWidget *>>
 	auto toolbar = new QToolBar();
 	toolbar->setIconSize({16, 16});
 
-	QAction *lastSeperator = nullptr;
+	QAction *lastSeparator = nullptr;
 
 	for (const auto &widgetGroup : widgetGroups) {
 		for (const auto &widget : widgetGroup) {
+			if (!widget) {
+				continue;
+			}
 			toolbar->addWidget(widget);
 		}
-		lastSeperator = toolbar->addSeparator();
+		lastSeparator = toolbar->addSeparator();
 	}
 
-	if (lastSeperator) {
-		toolbar->removeAction(lastSeperator);
+	if (lastSeparator) {
+		toolbar->removeAction(lastSeparator);
 	}
 
 	// Prevent "extension" button from showing up

From de8f31856dbbfa5786a9f684bfededdfb6bf49a1 Mon Sep 17 00:00:00 2001
From: WarmUpTill <19472752+WarmUpTill@users.noreply.github.com>
Date: Thu, 20 Nov 2025 18:41:41 +0100
Subject: [PATCH 3/3] Display warning if Twitch token expired or is invalid

---
 data/locale/en-US.ini         |   5 +-
 plugins/twitch/token.cpp      |  16 +++++-
 plugins/twitch/token.hpp      |   4 ++
 plugins/twitch/twitch-tab.cpp | 105 +++++++++++++++++++++++++++++++++-
 plugins/twitch/twitch-tab.hpp |  13 +++++
 5 files changed, 137 insertions(+), 6 deletions(-)

diff --git a/data/locale/en-US.ini b/data/locale/en-US.ini
index 8c152e568..d3c2761bd 100644
--- a/data/locale/en-US.ini
+++ b/data/locale/en-US.ini
@@ -1607,7 +1607,10 @@ AdvSceneSwitcher.twitchToken.moderator.chat.settings.manage="Manage channel's ch
 AdvSceneSwitcher.twitchToken.user.whispers.manage="Manage user's whispers."
 AdvSceneSwitcher.twitchToken.chat.read="View live stream chat messages."
 AdvSceneSwitcher.twitchToken.chat.edit="Send live stream chat messages."
-AdvSceneSwitcher.twitchToken.validateTimestamps="Validate timestamps of received Twitch event messages. (Recommended)"
+AdvSceneSwitcher.twitchToken.validateTimestamps="Validate timestamps of received Twitch event messages."
+AdvSceneSwitcher.twitchToken.warnIfInvalid="Display warning if the token expired or is invalid."
+AdvSceneSwitcher.twitchToken.warnIfInvalid.doNotShowAgain="Don't show again for this connection"
+AdvSceneSwitcher.twitchToken.warnIfInvalid.message="The Twitch connection \"%1\" is invalid.\nOpen connection settings or ignore?"
 
 AdvSceneSwitcher.twitch.selection.channel.open="Open channel"
 AdvSceneSwitcher.twitch.selection.channel.open.tooltip.details="Open channel in external application handling the HTTPS protocol."
diff --git a/plugins/twitch/token.cpp b/plugins/twitch/token.cpp
index 1af3c386b..912c17130 100644
--- a/plugins/twitch/token.cpp
+++ b/plugins/twitch/token.cpp
@@ -163,7 +163,8 @@ TwitchToken::TwitchToken(const TwitchToken &other)
 	  _userID(other._userID),
 	  _tokenOptions(other._tokenOptions),
 	  _eventSub(),
-	  _validateEventSubTimestamps(other._validateEventSubTimestamps)
+	  _validateEventSubTimestamps(other._validateEventSubTimestamps),
+	  _warnIfInvalid(other._warnIfInvalid)
 {
 }
 
@@ -174,6 +175,7 @@ TwitchToken &TwitchToken::operator=(const TwitchToken &other)
 	_userID = other._userID;
 	_tokenOptions = other._tokenOptions;
 	_validateEventSubTimestamps = other._validateEventSubTimestamps;
+	_warnIfInvalid = other._warnIfInvalid;
 	return *this;
 }
 
@@ -185,6 +187,9 @@ void TwitchToken::Load(obs_data_t *obj)
 	obs_data_set_default_bool(obj, "validateEventSubTimestamps", true);
 	_validateEventSubTimestamps =
 		obs_data_get_bool(obj, "validateEventSubTimestamps");
+	_warnIfInvalid = obs_data_has_user_value(obj, "warnIfInvalid")
+				 ? obs_data_get_bool(obj, "warnIfInvalid")
+				 : true;
 	_tokenOptions.clear();
 	OBSDataArrayAutoRelease options = obs_data_get_array(obj, "options");
 	size_t count = obs_data_array_count(options);
@@ -203,6 +208,7 @@ void TwitchToken::Save(obs_data_t *obj) const
 	obs_data_set_string(obj, "userID", _userID.c_str());
 	obs_data_set_bool(obj, "validateEventSubTimestamps",
 			  _validateEventSubTimestamps);
+	obs_data_set_bool(obj, "warnIfInvalid", _warnIfInvalid);
 	OBSDataArrayAutoRelease options = obs_data_array_create();
 	for (auto &option : _tokenOptions) {
 		OBSDataAutoRelease arrayObj = obs_data_create();
@@ -477,7 +483,9 @@ TwitchTokenSettingsDialog::TwitchTokenSettingsDialog(
 	  _tokenStatus(new QLabel()),
 	  _generalSettingsGrid(new QGridLayout()),
 	  _validateTimestamps(new QCheckBox(obs_module_text(
-		  "AdvSceneSwitcher.twitchToken.validateTimestamps")))
+		  "AdvSceneSwitcher.twitchToken.validateTimestamps"))),
+	  _warnIfInvalid(new QCheckBox(obs_module_text(
+		  "AdvSceneSwitcher.twitchToken.warnIfInvalid")))
 {
 	_showToken->setMaximumWidth(22);
 	_showToken->setFlat(true);
@@ -544,6 +552,7 @@ TwitchTokenSettingsDialog::TwitchTokenSettingsDialog(
 	layout->addLayout(_generalSettingsGrid);
 	layout->addWidget(optionsBox);
 	layout->addWidget(_validateTimestamps);
+	layout->addWidget(_warnIfInvalid);
 	layout->setContentsMargins(0, 0, 0, 0);
 	scrollArea->setWidget(contentWidget);
 
@@ -569,6 +578,7 @@ TwitchTokenSettingsDialog::TwitchTokenSettingsDialog(
 #ifndef VERIFY_TIMESTAMPS
 	_validateTimestamps->hide();
 #endif
+	_warnIfInvalid->setChecked(settings._warnIfInvalid);
 
 	_currentToken = settings;
 
@@ -777,6 +787,8 @@ bool TwitchTokenSettingsDialog::AskForSettings(QWidget *parent,
 	settings._tokenOptions = dialog.GetEnabledOptions();
 	settings._validateEventSubTimestamps =
 		dialog._validateTimestamps->isChecked();
+	settings._warnIfInvalid = dialog._warnIfInvalid->isChecked();
+
 	if (settings._eventSub) {
 		settings._eventSub->EnableTimestampValidation(
 			settings._validateEventSubTimestamps);
diff --git a/plugins/twitch/token.hpp b/plugins/twitch/token.hpp
index b3763af4e..f2e02cda7 100644
--- a/plugins/twitch/token.hpp
+++ b/plugins/twitch/token.hpp
@@ -55,6 +55,8 @@ class TwitchToken : public Item {
 	std::shared_ptr<EventSub> GetEventSub();
 	bool ValidateTimestamps() const { return _validateEventSubTimestamps; }
 	bool IsValid(bool forceUpdate = false) const;
+	bool WarnIfInvalid() const { return _warnIfInvalid; }
+	void SetWarnIfInvalid(bool value) { _warnIfInvalid = value; }
 	size_t PermissionCount() const { return _tokenOptions.size(); }
 
 private:
@@ -67,6 +69,7 @@ class TwitchToken : public Item {
 	std::set<TokenOption> _tokenOptions = TokenOption::GetAllTokenOptions();
 	std::shared_ptr<EventSub> _eventSub;
 	bool _validateEventSubTimestamps = false;
+	bool _warnIfInvalid = true;
 
 	static bool _setup;
 
@@ -131,6 +134,7 @@ private slots:
 	TwitchToken _currentToken;
 	std::unordered_map<std::string, QCheckBox *> _optionWidgets;
 	QCheckBox *_validateTimestamps;
+	QCheckBox *_warnIfInvalid;
 	QTimer _validationTimer;
 };
 
diff --git a/plugins/twitch/twitch-tab.cpp b/plugins/twitch/twitch-tab.cpp
index 771c07723..d7cfcc858 100644
--- a/plugins/twitch/twitch-tab.cpp
+++ b/plugins/twitch/twitch-tab.cpp
@@ -1,24 +1,47 @@
 #include "twitch-tab.hpp"
 #include "obs-module-helper.hpp"
+#include "plugin-state-helpers.hpp"
 #include "sync-helpers.hpp"
 #include "tab-helpers.hpp"
 #include "token.hpp"
 #include "ui-helpers.hpp"
 
+#include <QDialogButtonBox>
 #include <QTabWidget>
 
 namespace advss {
 
-static bool registerTab();
+static bool setup();
 static void setupTab(QTabWidget *);
-static bool registerTabDone = registerTab();
+static bool setupDone = setup();
 
 static TwitchConnectionsTable *tabWidget = nullptr;
 
-static bool registerTab()
+static QStringList getInvalidTokens();
+
+static bool setup()
 {
 	AddSetupTabCallback("twitchConnectionTab",
 			    TwitchConnectionsTable::Create, setupTab);
+
+	static const auto showInvalidWarnings = []() {
+		const auto invalidTokens = getInvalidTokens();
+		for (const auto &token : invalidTokens) {
+			QueueUITask(
+				[](void *tokenPtr) {
+					auto tokenName = static_cast<QString *>(
+						tokenPtr);
+					InvalidTokenDialog::ShowWarning(
+						*tokenName);
+				},
+				(void *)&token);
+		}
+	};
+
+	AddLoadStep([](obs_data_t *) {
+		AddPostLoadStep([]() { showInvalidWarnings(); });
+	});
+
 	return true;
 }
 
@@ -188,6 +211,25 @@ static void updateConnectionStatus(QTableWidget *table)
 	}
 }
 
+static QStringList getInvalidTokens()
+{
+	QStringList tokens;
+	for (const auto &t : GetTwitchTokens()) {
+		if (!t) {
+			continue;
+		}
+
+		auto token = std::static_pointer_cast<TwitchToken>(t);
+		if (!token->WarnIfInvalid() || token->IsValid(true)) {
+			continue;
+		}
+
+		tokens << QString::fromStdString(token->GetName());
+	}
+
+	return tokens;
+}
+
 static void setupTab(QTabWidget *tab)
 {
 	if (GetTwitchTokens().empty()) {
@@ -222,6 +264,63 @@ static void setupTab(QTabWidget *tab)
 			updateConnectionStatus(tabWidget->Table());
 		}
 	});
+
+	const auto invalidTokens = getInvalidTokens();
+	for (const auto &token : invalidTokens) {
+		// Constructing the warning dialog in the constructor of the settings
+		// window might lead to a crash, so wait for the settings window
+		// constructor to complete
+		QTimer::singleShot(0, tab, [token]() {
+			InvalidTokenDialog::ShowWarning(token);
+		});
+	}
+}
+
+void InvalidTokenDialog::ShowWarning(const QString &tokenName)
+{
+	auto weakToken = GetWeakTwitchTokenByQString(tokenName);
+	auto token = weakToken.lock();
+	if (!token) {
+		return;
+	}
+
+	auto dialog = new InvalidTokenDialog(tokenName);
+	dialog->setWindowTitle(obs_module_text("AdvSceneSwitcher.windowTitle"));
+	const bool ignore = dialog->exec() != DialogCode::Accepted;
+	token->SetWarnIfInvalid(!dialog->_doNotShowAgain->isChecked());
+	dialog->deleteLater();
+
+	if (ignore) {
+		return;
+	}
+
+	TwitchTokenSettingsDialog::AskForSettings(GetSettingsWindow(),
+						  *token.get());
+}
+
+InvalidTokenDialog::InvalidTokenDialog(const QString &name)
+	: QDialog(GetSettingsWindow()),
+	  _doNotShowAgain(new QCheckBox(obs_module_text(
+		  "AdvSceneSwitcher.twitchToken.warnIfInvalid.doNotShowAgain")))
+{
+	auto buttons = new QDialogButtonBox(QDialogButtonBox::Ignore |
+					    QDialogButtonBox::Open);
+
+	connect(buttons->button(QDialogButtonBox::Ignore),
+		&QPushButton::clicked, this, &QDialog::reject);
+	connect(buttons->button(QDialogButtonBox::Open), &QPushButton::clicked,
+		this, &QDialog::accept);
+	buttons->setCenterButtons(true);
+
+	const QString format(obs_module_text(
+		"AdvSceneSwitcher.twitchToken.warnIfInvalid.message"));
+	const QString message = format.arg(name);
+
+	auto layout = new QVBoxLayout;
+	layout->addWidget(new QLabel(message));
+	layout->addWidget(_doNotShowAgain);
+	layout->addWidget(buttons);
+	setLayout(layout);
 }
 
 } // namespace advss
diff --git a/plugins/twitch/twitch-tab.hpp b/plugins/twitch/twitch-tab.hpp
index 706b109f8..775b93005 100644
--- a/plugins/twitch/twitch-tab.hpp
+++ b/plugins/twitch/twitch-tab.hpp
@@ -1,6 +1,9 @@
 #pragma once
 #include "resource-table.hpp"
 
+#include <QCheckBox>
+#include <QDialog>
+
 namespace advss {
 
 class TwitchConnectionsTable final : public ResourceTable {
@@ -17,4 +20,14 @@ private slots:
 	TwitchConnectionsTable(QTabWidget *parent = nullptr);
 };
 
+class InvalidTokenDialog : public QDialog {
+	Q_OBJECT
+public:
+	static void ShowWarning(const QString &name);
+
+private:
+	InvalidTokenDialog(const QString &name);
+	QCheckBox *_doNotShowAgain;
+};
+
 } // namespace advss
